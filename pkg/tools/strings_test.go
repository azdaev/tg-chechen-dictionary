package tools

import (
	"strings"
	"testing"
)

func TestFormatTranslation(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:  "simple single meaning",
			input: "**—Ä—É—á–∫–∞** - —Ä—É—á–∫–∞ (–¥–ª—è –ø–∏—Å—å–º–∞)",
			expected: `üìù –†–£–ß–ö–ê

1Ô∏è‚É£ —Ä—É—á–∫–∞ (–¥–ª—è –ø–∏—Å—å–º–∞)`,
		},
		{
			name: "complex entry with multiple meanings",
			input: `**–†—É—á–∫–∞** - –∂ 1) —É–º–µ–Ω—å—à. –æ—Ç —Ä—É–∫–∞; 2) (–¥–ª—è –ø–∏—Å—å–º–∞) —Ä—É—á–∫–∞; —Å–∞–º–æ–ø–∏—à—É—â–∞—è ~–∞ - —à–∞ —è–∑–¥–µ–Ω —Ä—É—á–∫–∞; —à–∞—Ä–∏–∫–æ–≤–∞—è ~–∞ - —à–∞—Ä–∏–∫–∞–Ω —Ä—É—á–∫–∞; ~–∞ —Å –ø–µ—Ä–æ–º - –ø–µ—Ä–æ –π–æ–ª—É —Ä—É—á–∫–∞ 3) (–ø–æ—Å—É–¥—ã, –ø—Ä–∏–±–æ—Ä–∞, –º–µ–±–µ–ª–∏) —Ç”è–∞–º; (–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞) –º—É–∫—ä; (–≤–µ–¥—Ä–∞, –∫–æ—Ç–ª–∞) –∫”è–∞–π; –¥–≤–µ—Ä–Ω–∞—è ~–∞ - –Ω–∞—å”è–∞—Ä–∞–Ω —Ç”è–∞–º; ~–∞ –Ω–æ–∂–∞ - —É—å—Ä—Å–∞–Ω –º—É–∫—ä; ~–∏ –¥–∏–≤–∞–Ω–∞- –¥–∏–≤–∞–Ω–∞–Ω —Ç”è–∞—å–º–Ω–∞—à; –±–µ–∑ —Ä—É—á–µ–∫- —Ç”è–∞–º –±–æ—Ü—É—à ; –¥–æ–π—Ç–∏ –¥–æ ~–∏ –ø—Ä–æ—Å—Ç. - –¥–∞–Ω —Ö”è—É–º–∞ –¥–æ—Ü—á—É –¥–∞–ª–∞ (–∫—Ö–∞—á–∞)`,
			expected: `üìù –†–£–ß–ö–ê

1Ô∏è‚É£1) —É–º–µ–Ω—å—à. –æ—Ç —Ä—É–∫–∞
2Ô∏è‚É£2) (–¥–ª—è –ø–∏—Å—å–º–∞) —Ä—É—á–∫–∞
   ‚Ä¢ —Å–∞–º–æ–ø–∏—à—É—â–∞—è —Ä—É—á–∫–∞ ‚Üí —à–∞ —è–∑–¥–µ–Ω —Ä—É—á–∫–∞
   ‚Ä¢ —à–∞—Ä–∏–∫–æ–≤–∞—è —Ä—É—á–∫–∞ ‚Üí —à–∞—Ä–∏–∫–∞–Ω —Ä—É—á–∫–∞
   ‚Ä¢ —Ä—É—á–∫–∞ —Å –ø–µ—Ä–æ–º ‚Üí –ø–µ—Ä–æ –π–æ–ª—É —Ä—É—á–∫–∞

3Ô∏è‚É£3) (–ø–æ—Å—É–¥—ã, –ø—Ä–∏–±–æ—Ä–∞, –º–µ–±–µ–ª–∏) —Ç”è–∞–º
   ‚Ä¢ (–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞) –º—É–∫—ä
   ‚Ä¢ (–≤–µ–¥—Ä–∞, –∫–æ—Ç–ª–∞) –∫”è–∞–π
   ‚Ä¢ –¥–≤–µ—Ä–Ω–∞—è —Ä—É—á–∫–∞ ‚Üí –Ω–∞—å”è–∞—Ä–∞–Ω —Ç”è–∞–º
   ‚Ä¢ —Ä—É—á–∫–∞ –Ω–æ–∂–∞ ‚Üí —É—å—Ä—Å–∞–Ω –º—É–∫—ä
   ‚Ä¢ —Ä—É—á–∫–∏ –¥–∏–≤–∞–Ω–∞ ‚Üí –¥–∏–≤–∞–Ω–∞–Ω —Ç”è–∞—å–º–Ω–∞—à
   ‚Ä¢ –±–µ–∑ —Ä—É—á–µ–∫ ‚Üí —Ç”è–∞–º –±–æ—Ü—É—à
   ‚Ä¢ –¥–æ–π—Ç–∏ –¥–æ —Ä—É—á–∫–∏ –ø—Ä–æ—Å—Ç. ‚Üí –¥–∞–Ω —Ö”è—É–º–∞ –¥–æ—Ü—á—É –¥–∞–ª–∞ (–∫—Ö–∞—á–∞)`,
		},
		{
			name: "tree entry with examples",
			input: `**–î–µ—Ä–µ–≤–æ** - —Å 1) –¥–∏—Ç—Ç; —Ñ—Ä—É–∫—Ç–æ–≤–æ–µ ~ - —Å—Ç–æ—å–º–∏–π–Ω –¥–∏—Ç—Ç; –ª–∏—Å—Ç–≤–µ–Ω–Ω–æ–µ ~ - –≥”è–∞—à –¥–æ–ª—É –¥–∏—Ç—Ç 2) (–º–∞—Ç–µ—Ä–∏–∞–ª) –¥–µ—á–∏–≥; —Å—Ç–æ–ª –∫—Ä–∞—Å–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞ ‚Äì —Ü”è–µ—á—É –¥–µ—á–∏–≥–∞–Ω —Å—Ç–æ–ª ; —Ä–æ–¥–æ—Å–ª–æ–≤–Ω–æ–µ ~ -—Å–∏–ª—Å–∏–ª`,
			expected: `üìù –î–ï–†–ï–í–û

1Ô∏è‚É£1) –¥–∏—Ç—Ç
   ‚Ä¢ —Ñ—Ä—É–∫—Ç–æ–≤–æ–µ –¥–µ—Ä–µ–≤–æ ‚Üí —Å—Ç–æ—å–º–∏–π–Ω –¥–∏—Ç—Ç
   ‚Ä¢ –ª–∏—Å—Ç–≤–µ–Ω–Ω–æ–µ –¥–µ—Ä–µ–≤–æ ‚Üí –≥”è–∞—à –¥–æ–ª—É –¥–∏—Ç—Ç

2Ô∏è‚É£2) (–º–∞—Ç–µ—Ä–∏–∞–ª) –¥–µ—á–∏–≥
   ‚Ä¢ —Å—Ç–æ–ª –∫—Ä–∞—Å–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞ ‚Äì —Ü”è–µ—á—É –¥–µ—á–∏–≥–∞–Ω —Å—Ç–æ–ª
   ‚Ä¢ —Ä–æ–¥–æ—Å–ª–æ–≤–Ω–æ–µ –¥–µ—Ä–µ–≤–æ ‚Üí —Å–∏–ª—Å–∏–ª`,
		},
		{
			name: "verb entry",
			input: `**–î–∏—Ç–∞** - 1) –≤ —Ä–∞–∑–Ω. –∑–Ω–∞—á. –æ—Å—Ç–∞–≤–∏—Ç—å, –ø–æ–∫–∏–Ω—É—Ç—å; –∞—Å —Å–∞–π–Ω –∞—Ö—á–∞ —Ü—É—å–Ω–≥–∞—Ö—å –¥–∏—Ç–∏–Ω–∞ —è –æ—Å—Ç–∞–≤–∏–ª —É –Ω–µ–≥–æ —Å–≤–æ–∏ –¥–µ–Ω—å–≥–∏; 2) —Ä–∞–∑–≤–µ—Å—Ç–∏—Å—å, —Ä–∞—Å—Ç–æ—Ä–≥–Ω—É—Ç—å –±—Ä–∞–∫; —Ü–æ –∑—É–¥–∞ –π–∏—Ç–∏–Ω–∞ –æ–Ω —Ä–∞–∑–≤–µ–ª—Å—è —Å –∂–µ–Ω–æ–π;  –º–æ—Å—Ç–∞–≥”è –≤–∏—Ç–∞ –ø—Ä–æ—Å—Ç–∏—Ç—å –≤—Ä–∞–≥—É (—Ç. –µ. –æ—Å—Ç–∞–≤–∏—Ç—å –±–µ–∑ –º—â–µ–Ω–∏—è); —Ü–∏–≥–∞—å—Ä–∫–∞ –π–∏—Ç–∞ –±—Ä–æ—Å–∏—Ç—å –∫—É—Ä–∏—Ç—å (–±—É–∫–≤, –æ—Å—Ç–∞–≤–∏—Ç—å –ø–∞–ø–∏—Ä–æ—Å—É); –º–µ–∫—Ö–∞—à –¥–∏—Ç–∞ –æ—Å—Ç–∞–≤–∏—Ç—å —É—Å—ã (—Ç. –µ. –Ω–µ –±—Ä–∏—Ç—å —É—Å–æ–≤)`,
			expected: `üìù –î–ò–¢–ê

1Ô∏è‚É£1) –≤ —Ä–∞–∑–Ω. –∑–Ω–∞—á. –æ—Å—Ç–∞–≤–∏—Ç—å, –ø–æ–∫–∏–Ω—É—Ç—å
   ‚Ä¢ –∞—Å —Å–∞–π–Ω –∞—Ö—á–∞ —Ü—É—å–Ω–≥–∞—Ö—å –¥–∏—Ç–∏–Ω–∞ —è –æ—Å—Ç–∞–≤–∏–ª —É –Ω–µ–≥–æ —Å–≤–æ–∏ –¥–µ–Ω—å–≥–∏

2Ô∏è‚É£2) —Ä–∞–∑–≤–µ—Å—Ç–∏—Å—å, —Ä–∞—Å—Ç–æ—Ä–≥–Ω—É—Ç—å –±—Ä–∞–∫
   ‚Ä¢ —Ü–æ –∑—É–¥–∞ –π–∏—Ç–∏–Ω–∞ –æ–Ω —Ä–∞–∑–≤–µ–ª—Å—è —Å –∂–µ–Ω–æ–π
   ‚Ä¢ –º–æ—Å—Ç–∞–≥”è –≤–∏—Ç–∞ –ø—Ä–æ—Å—Ç–∏—Ç—å –≤—Ä–∞–≥—É (—Ç. –µ. –æ—Å—Ç–∞–≤–∏—Ç—å –±–µ–∑ –º—â–µ–Ω–∏—è)
   ‚Ä¢ —Ü–∏–≥–∞—å—Ä–∫–∞ –π–∏—Ç–∞ –±—Ä–æ—Å–∏—Ç—å –∫—É—Ä–∏—Ç—å (–±—É–∫–≤, –æ—Å—Ç–∞–≤–∏—Ç—å –ø–∞–ø–∏—Ä–æ—Å—É)
   ‚Ä¢ –º–µ–∫—Ö–∞—à –¥–∏—Ç–∞ –æ—Å—Ç–∞–≤–∏—Ç—å —É—Å—ã (—Ç. –µ. –Ω–µ –±—Ä–∏—Ç—å —É—Å–æ–≤)`,
		},
		{
			name: "entry without bold word",
			input: `–¥–µ—á–∏–≥-–ø—Ö—å–æ–ª–∏–Ω; ~—ã–µ —Ä–∞–±–æ—Ç—ã - –¥–µ—á–∏–≥-–ø—Ö—å–æ–ª–∏–Ω –±–µ–ª—Ö–∞—à`,
			expected: `1Ô∏è‚É£ –¥–µ—á–∏–≥-–ø—Ö—å–æ–ª–∏–Ω
   ‚Ä¢ ~—ã–µ —Ä–∞–±–æ—Ç—ã ‚Üí –¥–µ—á–∏–≥-–ø—Ö—å–æ–ª–∏–Ω –±–µ–ª—Ö–∞—à`,
		},
		{
			name:     "empty input",
			input:    "",
			expected: "",
		},
		{
			name: "single meaning without numbering",
			input: `**–î–µ—Ç—Ç–∞** - –¥–æ–∏—Ç—å; –µ—Ç—Ç –±–µ—Ç—Ç–∞ –¥–æ–∏—Ç—å –∫–æ—Ä–æ–≤—É`,
			expected: `üìù –î–ï–¢–¢–ê

1Ô∏è‚É£ –¥–æ–∏—Ç—å
   ‚Ä¢ –µ—Ç—Ç –±–µ—Ç—Ç–∞ –¥–æ–∏—Ç—å –∫–æ—Ä–æ–≤—É`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := FormatTranslation(tt.input)

			// Normalize whitespace for comparison
			normalizeWhitespace := func(s string) string {
				return strings.TrimSpace(strings.ReplaceAll(s, "\r\n", "\n"))
			}

			expected := normalizeWhitespace(tt.expected)
			actual := normalizeWhitespace(result)

			if actual != expected {
				t.Errorf("FormatTranslation() =\n%q\nwant:\n%q", actual, expected)
			}
		})
	}
}

func TestCleanTranslation(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "with leading dash",
			input:    "- –¥–µ—á–∏–≥",
			expected: "–¥–µ—á–∏–≥",
		},
		{
			name:     "with spaces",
			input:    "  —É–º–µ–Ω—å—à. –æ—Ç —Ä—É–∫–∞  ",
			expected: "—É–º–µ–Ω—å—à. –æ—Ç —Ä—É–∫–∞",
		},
		{
			name:     "normal text",
			input:    "—Ä—É—á–∫–∞ (–¥–ª—è –ø–∏—Å—å–º–∞)",
			expected: "—Ä—É—á–∫–∞ (–¥–ª—è –ø–∏—Å—å–º–∞)",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := cleanTranslation(tt.input)
			if result != tt.expected {
				t.Errorf("cleanTranslation() = %q, want %q", result, tt.expected)
			}
		})
	}
}

func TestParseExamples(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected []string
	}{
		{
			name:  "single example",
			input: "—Å–∞–º–æ–ø–∏—à—É—â–∞—è ~–∞ - —à–∞ —è–∑–¥–µ–Ω —Ä—É—á–∫–∞",
			expected: []string{
				"—Å–∞–º–æ–ø–∏—à—É—â–∞—è ~–∞ ‚Üí —à–∞ —è–∑–¥–µ–Ω —Ä—É—á–∫–∞",
			},
		},
		{
			name:  "multiple examples with semicolons",
			input: "—Å–∞–º–æ–ø–∏—à—É—â–∞—è ~–∞ - —à–∞ —è–∑–¥–µ–Ω —Ä—É—á–∫–∞; —à–∞—Ä–∏–∫–æ–≤–∞—è ~–∞ - —à–∞—Ä–∏–∫–∞–Ω —Ä—É—á–∫–∞; ~–∞ —Å –ø–µ—Ä–æ–º - –ø–µ—Ä–æ –π–æ–ª—É —Ä—É—á–∫–∞",
			expected: []string{
				"—Å–∞–º–æ–ø–∏—à—É—â–∞—è ~–∞ ‚Üí —à–∞ —è–∑–¥–µ–Ω —Ä—É—á–∫–∞",
				"—à–∞—Ä–∏–∫–æ–≤–∞—è ~–∞ ‚Üí —à–∞—Ä–∏–∫–∞–Ω —Ä—É—á–∫–∞",
				"~–∞ —Å –ø–µ—Ä–æ–º ‚Üí –ø–µ—Ä–æ –π–æ–ª—É —Ä—É—á–∫–∞",
			},
		},
		{
			name:  "complex sentence example",
			input: "–∞—Å —Å–∞–π–Ω –∞—Ö—á–∞ —Ü—É—å–Ω–≥–∞—Ö—å –¥–∏—Ç–∏–Ω–∞ —è –æ—Å—Ç–∞–≤–∏–ª —É –Ω–µ–≥–æ —Å–≤–æ–∏ –¥–µ–Ω—å–≥–∏",
			expected: []string{
				"–∞—Å —Å–∞–π–Ω –∞—Ö—á–∞ —Ü—É—å–Ω–≥–∞—Ö—å –¥–∏—Ç–∏–Ω–∞ —è –æ—Å—Ç–∞–≤–∏–ª —É –Ω–µ–≥–æ —Å–≤–æ–∏ –¥–µ–Ω—å–≥–∏",
			},
		},
		{
			name:     "no examples",
			input:    "–ø—Ä–æ—Å—Ç–æ —Ç–µ–∫—Å—Ç –±–µ–∑ –ø—Ä–∏–º–µ—Ä–æ–≤",
			expected: []string{"–ø—Ä–æ—Å—Ç–æ —Ç–µ–∫—Å—Ç –±–µ–∑ –ø—Ä–∏–º–µ—Ä–æ–≤"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := parseExamples(tt.input)
			if len(result) != len(tt.expected) {
				t.Errorf("parseExamples() returned %d examples, want %d", len(result), len(tt.expected))
				t.Errorf("got: %v", result)
				t.Errorf("want: %v", tt.expected)
				return
			}

			for i, expected := range tt.expected {
				if i >= len(result) || result[i] != expected {
					t.Errorf("parseExamples()[%d] = %q, want %q", i, result[i], expected)
				}
			}
		})
	}
}

func TestGetNumberEmoji(t *testing.T) {
	tests := []struct {
		input    int
		expected string
	}{
		{1, "1Ô∏è‚É£"},
		{2, "2Ô∏è‚É£"},
		{3, "3Ô∏è‚É£"},
		{10, "üîü"},
		{11, "11Ô∏è‚É£"},
		{0, "0Ô∏è‚É£"},
	}

	for _, tt := range tests {
		t.Run("", func(t *testing.T) {
			result := getNumberEmoji(tt.input)
			if result != tt.expected {
				t.Errorf("getNumberEmoji(%d) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}

func TestReplaceTildeWithWord(t *testing.T) {
	tests := []struct {
		name     string
		text     string
		word     string
		expected string
	}{
		{
			name:     "simple tilde replacement",
			text:     "—Ñ—Ä—É–∫—Ç–æ–≤–æ–µ ~ ‚Üí —Å—Ç–æ—å–º–∏–π–Ω –¥–∏—Ç—Ç",
			word:     "–¥–µ—Ä–µ–≤–æ",
			expected: "—Ñ—Ä—É–∫—Ç–æ–≤–æ–µ –¥–µ—Ä–µ–≤–æ ‚Üí —Å—Ç–æ—å–º–∏–π–Ω –¥–∏—Ç—Ç",
		},
		{
			name:     "tilde with ending",
			text:     "—Å–∞–º–æ–ø–∏—à—É—â–∞—è ~–∞ ‚Üí —à–∞ —è–∑–¥–µ–Ω —Ä—É—á–∫–∞",
			word:     "—Ä—É—á–∫–∞",
			expected: "—Å–∞–º–æ–ø–∏—à—É—â–∞—è —Ä—É—á–∫–∞ ‚Üí —à–∞ —è–∑–¥–µ–Ω —Ä—É—á–∫–∞",
		},
		{
			name:     "multiple tildes with different endings",
			text:     "–¥–≤–µ—Ä–Ω–∞—è ~–∞ ‚Üí –Ω–∞—å”è–∞—Ä–∞–Ω —Ç”è–∞–º; ~–∏ –¥–∏–≤–∞–Ω–∞ ‚Üí –¥–∏–≤–∞–Ω–∞–Ω —Ç”è–∞—å–º–Ω–∞—à",
			word:     "—Ä—É—á–∫–∞",
			expected: "–¥–≤–µ—Ä–Ω–∞—è —Ä—É—á–∫–∞ ‚Üí –Ω–∞—å”è–∞—Ä–∞–Ω —Ç”è–∞–º; —Ä—É—á–∫–∏ –¥–∏–≤–∞–Ω–∞ ‚Üí –¥–∏–≤–∞–Ω–∞–Ω —Ç”è–∞—å–º–Ω–∞—à",
		},
		{
			name:     "tilde with plural ending",
			text:     "~–∏ –¥–∏–≤–∞–Ω–∞ ‚Üí –¥–∏–≤–∞–Ω–∞–Ω —Ç”è–∞—å–º–Ω–∞—à",
			word:     "—Ä—É—á–∫–∞",
			expected: "—Ä—É—á–∫–∏ –¥–∏–≤–∞–Ω–∞ ‚Üí –¥–∏–≤–∞–Ω–∞–Ω —Ç”è–∞—å–º–Ω–∞—à",
		},
		{
			name:     "no tilde",
			text:     "–æ–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç –±–µ–∑ —Ç–∏–ª—å–¥—ã",
			word:     "—Å–ª–æ–≤–æ",
			expected: "–æ–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç –±–µ–∑ —Ç–∏–ª—å–¥—ã",
		},
		{
			name:     "empty word",
			text:     "—Ç–µ–∫—Å—Ç —Å ~ —Ç–∏–ª—å–¥–æ–π",
			word:     "",
			expected: "—Ç–µ–∫—Å—Ç —Å ~ —Ç–∏–ª—å–¥–æ–π",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := replaceTildeWithWord(tt.text, tt.word)
			if result != tt.expected {
				t.Errorf("replaceTildeWithWord() = %q, want %q", result, tt.expected)
			}
		})
	}
}

func TestGetWordBase(t *testing.T) {
	tests := []struct {
		word     string
		expected string
	}{
		{"—Ä—É—á–∫–∞", "—Ä—É—á–∫"},
		{"–¥–µ—Ä–µ–≤–æ", "–¥–µ—Ä–µ–≤"},
		{"—Å—Ç–æ–ª", "—Å—Ç–æ–ª"},
		{"–¥–æ–º", "–¥–æ–º"},
		{"–º–∞–º–∞", "–º–∞–º"},
		{"–ø–∞–ø–∞", "–ø–∞–ø"},
		{"", ""},
		{"–∞", "–∞"},
	}

	for _, tt := range tests {
		t.Run(tt.word, func(t *testing.T) {
			result := getWordBase(tt.word)
			if result != tt.expected {
				t.Errorf("getWordBase(%q) = %q, want %q", tt.word, result, tt.expected)
			}
		})
	}
}